using System.Collections;
using System.Net;
using System.Text;
using Fluxzy.Interop.Pcap;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Tls;
using Org.BouncyCastle.Tls.Crypto;
using Org.BouncyCastle.Tls.Crypto.Impl.BC;
using Org.BouncyCastle.Utilities.Encoders;

namespace Fluxzy.Bulk.BcCli
{
    /// <summary>
    /// Check list ALPN
    /// Client Certificate (OK) 
    /// Master KEY NOn (OK pour client random et server random )
    /// </summary>
    internal class Program
    {
        static async Task Main(string[] args)
        {
            await using var tcpProvider = new CapturedTcpConnectionProvider();
            
            var uriRaw
                = "https://sandbox.smartizy.com/global-health-check";
            if (!Uri.TryCreate(uriRaw, UriKind.Absolute, out var uri)) {
                throw new Exception("Invalid URI");
            }

            var connection = tcpProvider.Create("test.pcap");

            var ipAdress = (await Dns.GetHostAddressesAsync(uri.Host)).First();

            var endPoint = await connection.ConnectAsync(ipAdress, uri.Port);

            var entireRequest = $"GET {uri.PathAndQuery} HTTP/1.1\r\n" +
                                $"Host: {uri.Host}\r\n" +
                                $"User-Agent: Coco\r\n" +
                                $"Accept: text/plain\r\n" +
                                $"Connection: close\r\n" +
                                $"X-Header-Popo: Dodo\r\n\r\n";

            var stream = connection.GetStream();
            var secureRandom = new SecureRandom();
            var crypto = new FluxzyCrypto(secureRandom);

            var cl = new FluxzyTlsClient(crypto);

            //SecurityParameters securityParameters;
            //securityParameters.MasterSecret.Destroy();

            var protocol = new FluxzyClientProtocol(stream) {
                
            };

            protocol.Connect(cl);


            var clientRandom = protocol.PlainSecurityParameters.ClientRandom; 
            var masterSecret = crypto.MasterSecret;

            var text = string.Format("# Generated by Fluxzy\r\nCLIENT_RANDOM {0} {1}",
                Hex.ToHexString(clientRandom),
                Hex.ToHexString(masterSecret));

            File.WriteAllText("ssl.txt", text);
            

            stream = protocol.Stream; 

            await stream.WriteAsync(Encoding.ASCII.GetBytes(entireRequest));
            await stream.FlushAsync();

            var streamReader = new StreamReader(stream);

            var response = await streamReader.ReadToEndAsync();

            
            Console.WriteLine(response);
            
            await Task.Delay(2000);
        }

       
    }

    public class FluxzyClientProtocol : TlsClientProtocol
    {
        public FluxzyClientProtocol(Stream stream)
            : base(stream)
        {

        }

        public SecurityParameters PlainSecurityParameters => Context.SecurityParameters; 
    }




    class FluxzyTlsClient : DefaultTlsClient
    {
        public FluxzyTlsClient(TlsCrypto crypto)
            : base(crypto)
        {
        }

        public override TlsAuthentication GetAuthentication()
        {
            return new FluxzyTlsAuthentication(); 
        }
    }
    

    // Need class to handle certificate auth
    class FluxzyTlsAuthentication : TlsAuthentication
    {
        public void NotifyServerCertificate(TlsServerCertificate serverCertificate)
        {
            
        }

        

        public TlsCredentials? GetClientCredentials(CertificateRequest certificateRequest)
        {
            return null; 
        }
    }

    class FluxzyCrypto : BcTlsCrypto
    {
        public FluxzyCrypto(SecureRandom sr)
            : base(sr)
        {
            
        }

        public override TlsSecret GenerateRsaPreMasterSecret(ProtocolVersion version)
        {
            var res =  base.GenerateRsaPreMasterSecret(version);

            return res; 
        }
        

        public override TlsSecret AdoptSecret(TlsSecret secret)
        {
            var resultSecret =  base.AdoptSecret(secret);

            // byte[] data = new byte[1024];
            var data = secret.Extract();
            MasterSecret = new byte[data.Length];
            data.CopyTo(MasterSecret, 0);
            
            return resultSecret; 
        }

        public byte[]?  MasterSecret { get; set; }
    }

    

    
}