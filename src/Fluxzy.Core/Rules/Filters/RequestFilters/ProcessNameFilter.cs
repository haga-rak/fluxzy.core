// Copyright 2021 - Haga Rakotoharivelo - https://github.com/haga-rak

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Fluxzy.Core;
using Fluxzy.Misc;

namespace Fluxzy.Rules.Filters.RequestFilters
{
    /// <summary>
    ///     Select exchanges initiated by processes with the specified names.
    /// </summary>
    [FilterMetaData(
        LongDescription = "Select exchanges initiated by processes with the specified names. " +
                          "Process names are matched case-insensitively. " +
                          "On Windows, the .exe extension can be omitted. " +
                          "Process tracking must be enabled and the connection must originate from localhost."
    )]
    public class ProcessNameFilter : Filter
    {
        public ProcessNameFilter()
        {
        }

        public ProcessNameFilter(params string[] processNames)
        {
            ProcessNames = processNames.ToList();
        }

        public override Guid Identifier =>  
            (nameof(ProcessNameFilter) + string.Join("^", ProcessNames) + Inverted).GetMd5Guid();

        [FilterDistinctive(Description = "List of process names to match")]
        public List<string> ProcessNames { get; set; } = new();

        public override FilterScope FilterScope => FilterScope.RequestHeaderReceivedFromClient;

        public override string AutoGeneratedName => ProcessNames.Count == 1
            ? $"Process name `{ProcessNames.First()}`"
            : $"Process name among `{string.Join(", ", ProcessNames)}`";

        public override string GenericName => "Filter by process name";

        public override string ShortName => "pname";

        protected override bool InternalApply(
            ExchangeContext? exchangeContext,
            IAuthority authority,
            IExchange? exchange,
            IFilteringContext? filteringContext)
        {
            var processInfo = exchange?.ProcessInfo;

            if (processInfo?.ProcessPath == null)
                return false;

            var actualProcessName = Path.GetFileName(processInfo.ProcessPath);

            foreach (var expectedName in ProcessNames)
            {
                if (MatchesProcessName(actualProcessName, expectedName))
                    return true;
            }

            return false;
        }

        private static bool MatchesProcessName(string actualName, string expectedName)
        {
            if (string.IsNullOrEmpty(actualName) || string.IsNullOrEmpty(expectedName))
                return false;

            if (actualName.Equals(expectedName, StringComparison.OrdinalIgnoreCase))
                return true;

            var actualWithoutExe = RemoveExeExtension(actualName);
            var expectedWithoutExe = RemoveExeExtension(expectedName);

            return actualWithoutExe.Equals(expectedWithoutExe, StringComparison.OrdinalIgnoreCase);
        }

        private static string RemoveExeExtension(string name)
        {
            if (name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
                return name.Substring(0, name.Length - 4);

            return name;
        }

        public override IEnumerable<FilterExample> GetExamples()
        {
            yield return new FilterExample(
                "Filter traffic from curl process",
                new ProcessNameFilter("curl"));

            yield return new FilterExample(
                "Filter traffic from curl or wget processes",
                new ProcessNameFilter("curl", "wget"));
        }
    }
}
